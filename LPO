#!/usr/bin/perl -w

use warnings;
use strict;
use v5.10;

#Die if there is no arguments
die "I need a file!
    use: ./LPO <-d> <-cnf> FILE" if @ARGV == 0;

# Try to open the file in the last argument
open(INPUT, "<", $ARGV[-1]) or die "Impossible to open \"$ARGV[-1]\"
use: ./LPO <-d> <-cnf> FILE\n";

my $d;          # Debugger Option
my $lines;      # Line catcher of the INPUT
my @entries;    # Array with the lines

# Catching Options
foreach(@ARGV)
{
    when("-d")  #Debugger Option
    {
        $d = 1;    
    }
}

# Puting the INPUT in @entries
while ($lines = <INPUT>)
{push (@entries, $lines);}

close(INPUT);

say "\n----------------DEBBUGER----------------" if $d;
say "\nINPUT:\n" if $d;

say @entries if $d;

say "\nREADING FILE:\n" if $d;

my %vars;       # Hash with the information of the variables
my $claus;      # String with the clause
my @conds;      # Array with the conditions for the last clause
my $i;          # Actual line of the INPUT

# Processing loop
while ($i = shift @entries)
{
    # Check if the actual line is a variable declaration
    if ($i =~ m/([A-Z]+)\s*:\s*(\d+)\s+(\d+)/)
    {
        say $1 . " = {" . $2 . " ... " . $3 . "}" if $d;
        $vars{$1} = [$2, $3, "x"]; #The 'x' is a indicator used after
    }
    else 
    {   
        # Check if the actual line is a clause
        if ($i =~ 
           m/
                (
                    [-]?[a-z]+      # Name of the predicative

                    [(]
                    ([A-Z]+)\s*     # First parameter
                    (,\s*[A-Z]+)*   # Others parameters
                    [)]
                )+                  # One or more predicatives
                
                \s*[.]\s*           # End Of Predicatives
                
                (                   # Conditions
                    (
                        ([A-Z]+|\d+)\s*     # Variable or number 
                        (
                            [+-]\s*         # Operation applied
                            ([A-Z]+|\d+)\s* # Variable or number
                        )*
                                            
                        ([=<>]|!=)\s*   # Condition
                        
                        ([A-Z]+|\d+)\s*     # Variable or number 
                        (
                            [+-]\s*         # Operation applied
                            ([A-Z]+|\d+)\s* # Variable or number
                        )*
                    )+                    
                    [.]
                )?$
            /x
        )
        {   
            # Catching the clauses
            while ($i =~ s/([-]?\w+[(][A-Z,\s]+[)])\s*//)
            {
                $claus .= $1 . " ";
            }
            say "\nclausule:" if $d;
            print "    " if $d;
            say $claus if $d;
            
            #Catching the conditions
            say "conditions: " if $d;
            while ($i =~ s/
                            ([A-Z]+|\d+)     # First term of the condition
                            (
                                \s*
                                [+-]         # Operation applied to the term
                                \s*
                                ([A-Z]+|\d+) # Operator applied to the term
                            )*               # Any number of operations
                            \s*
                            [=<>!]+          # Comparison Operator
                            \s*
                            ([A-Z]+|\d+)     # Second term of the condition
                            (
                                \s*
                                [+-]         # Operation applied to the term
                                \s*
                                ([A-Z]+|\d+) # Operator applied to the term
                            )*               # Any number of operations
                        //x)
            {
                print "    " if $d;
                say $& if $d;
                push(@conds, $&);
            }
            
            # Here we start to recursively print
            say "\nPRINTING:\n" if $d;
            $claus =~ m/([A-Z]+)/; # Catch the first variable 
            # Die if the variable wasn't declared
            die "Variable $1 wasn't declared" unless defined $vars{$1}; 
            # The recursive function
            insert($claus,      # String with the clause 
                   $1,          # Name of one of the variables
                   {%vars},     # Reference to the variable hash
                   [@conds]);   # Reference to the array of conditions    
        }
        #die if the actual line is either not a clause nor a declaration
        else{die "error";}
    }
    #empty the conditions and the clause
    @conds = ();
    $claus = "";
}

# Recursive function to print the clauses
sub insert
{
    my $clause = shift;     # The clauses with some variable
    my $var    = shift;     # A variable in the clause
    my $vHash  = shift;     # A Hash reference with all the variables
    my $checks = shift;     # A Array reference with the conditions
    my $min    = $$vHash{$var}->[0]; # Least value of the $var domain
    my $max    = $$vHash{$var}->[1]; # Greater value of the $var domain
    my $aux;                # Auxiliar variable
    
    #die if the variable was not declared
    die "Variable $var wasn't declared" unless defined $vHash->{$var};
    
    # Printing the clauses
    for(my $i = $min; $i <= $max; $i++)
    {
        $$vHash{$var}[2] = $i; #Store the actual value of the variable
        
        # Check if matches the conditions 
        # or if there is no enough information
        if(chkConditions($vHash, $checks))
        {   
            $aux = $clause;
            # Change the variable to its actual value
            $aux =~ s/$var/$i/g;
            
            if($aux =~ m/([A-Z]+)/)
            {
                insert($aux, $1, $vHash, $checks);
            }
            else 
            {
                print "to file -> " if $d;
                $aux =~ s/\s*$/./;
                say $aux;
            }
        }   
    }
    $$vHash{$var}[2] = 'x';
}

sub chkConditions
{
    my $vHash  = shift;
    my $checks = shift;
    foreach(@$checks)
    {
        when(/(.*)!=(.*)/)
        {
            return 0 if(!chk($1, $2, $vHash, $checks, "!"));
        }
        when(/(.*)<(.*)/)
        {
            return 0 if(!chk($1, $2, $vHash, $checks, "<"));
        }
        when(/(.*)>(.*)/)
        {
            return 0 if(!chk($1, $2, $vHash, $checks, ">"));
        }
        when(/(.*)=(.*)/)
        {
            return 0 if(!chk($1, $2, $vHash, $checks, "="));
        }
    }
    return 1;
}

sub chk
{
    my $left   = shift;
    my $right  = shift;
    my $vHash  = shift;
    my $checks = shift;
    my $op     = shift;
    my $first = 0;
    my $second = 0;
    my $plus = 1;
    while($left =~ s/([A-Z]+|\d+)//)
    {
        if(defined $$vHash{$1})
        {
            return 1 if $$vHash{$1}[2] eq 'x';
            $first += $$vHash{$1}[2]*$plus;
        }
        else
        {
            $first += $1*$plus;
        }
        if($left =~ s/([+-])//)
        {
            $plus = +1 if $1 eq '+';
            $plus = -1 if $1 eq '-';
        }
    }
    $plus = 1;
    while($right =~ s/([A-Z]+|\d+)//)
    {
        if(defined $$vHash{$1})
        {
            return 1 if $$vHash{$1}[2] eq 'x';
            $second += $$vHash{$1}[2]*$plus;
        }
        else
        {
            $second += $1*$plus;
        }
        if($right =~ s/([+-])//)
        {
            $plus = +1 if $1 eq '+';
            $plus = -1 if $1 eq '-';
        }
    }
    given($op)
    {
        when("=")
        {
            return $first == $second;
        }
        when("<")
        {
            return $first <  $second;
        }
        when(">")
        {
            return $first >  $second;
        }
        when("!")
        {
            return $first != $second;
        }
    }
    return 0;
}
